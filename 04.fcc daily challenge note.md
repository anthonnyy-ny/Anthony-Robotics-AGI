

#### 9/15  Thermostat Adjuster                    ez
---
hints- function
tools- chatgpt
1st
```python=
def adjust_thermostat(temp, target):
    if temp<target:
        return "heat"
    if temp>target:
        return "cool"
    else:
        return "hold"
```


#### 9/20 File Storage           ez
---
hints- basic arithmetic exchange
tools- chatgpt
1st
```python=
def number_of_files(file_size, file_unit, drive_size_gb):
    if file_unit=="B":
        size_in_bytes=file_size
    elif file_unit=="KB":
        size_in_bytes=file_size*1000
    elif file_unit=="MB": 
        size_in_bytes=file_size*1000*1000
    else:
        raise ValueError("Unit must be 'b','kb','mb'")
    
    drive_in_bytes=drive_size_gb*1000*1000*1000

    return drive_in_bytes//size_in_bytes
```


#### 9/21 Video Storage                                  ez
---
hints- advanced arithmetic exchange
tools- chatgpt
1st
```python=
def number_of_videos(video_size, video_unit, drive_size, drive_unit):
    #dict
    unit_map={
        "B":1,
        "KB":1000,
        "MB":1000**2,
        "GB":1000**3,
        "TB":1000**4,
    }

    if video_unit not in ["KB","MB","GB"]:
        return "Invalid video unit"
    
    if drive_unit not in ["GB","TB"]:
        return "Invalid drive unit"
    
    video_bytes=video_size*unit_map[video_unit]

    drive_bytes=drive_size*unit_map[drive_unit]

    return drive_bytes//video_bytes
```


#### 9/22 Digits vs Letters                ez
---
hints- forloop, ifelse, isalpha(), isdigit()
tools- chatgpt
1st
```python=
def digits_or_letters(s:str)->str:
    digits,letters=0,0

    for c in s:
        if c.isdigit():
            digits+=1
        elif c.isalpha():
            letters+=1
    
    if digits>letters:
        return "digits"
    elif letters>digits:
        return "letters"
    else:
        return "tie"
```

#### 9/23 String Mirror              ez
---
hints- for loop, ifelse, isalpha(), [::-1]
tools- chatgpt
1st
```python=
def is_mirror(s1:str, s2:str)->bool:
	#another method 过滤掉非字母字符
	#f1 = "".join(ch for ch in s1 if ch.isalpha())
    #f2 = "".join(ch for ch in s2 if ch.isalpha())
    f1=""
    for ch in s1:
        if ch.isalpha():
            f1+=ch
    f2=""
    for ch in s2:
        if ch.isalpha():
            f2+=ch
    
    return f1==f2[::-1]
```


#### 9/25 2nd Largest                   ez
---
hints- list() set() reverse=True
tools- chatgpt
1st
```python=
def second_largest(nums):

    dist=list(set(nums))

    if len(dist)<2:
        return None
    
    dist.sort(reverse=True)

    return dist[1]
```


#### 9/27 Spam Detector                     ez
---
hints-
tools- chatgpt
##### 题目说明
---
判断给定格式 `"+A (BBB) CCC-DDDD"` 的电话号码是否为 **spam**
正则 \+(\d+) \((\d{3})\) (\d{3})-(\d{4}) 用来严格解析输入格式；不符合格式会抛 ValueError。
规则1 按你原文直译：只要国家码长度大于 2 或 国家码不是以 0 开头，就判为 spam。
（注意：这是原文给出的条件——按字面实现。如果你本意不是这样，告诉我我可以把逻辑改为“国家码长度 > 2 且 不以 0 开头才算 spam”等。）
规则3：先把 CCC 三位分别相加得到整数（例如 1+2+3=6），把这个整数转为字符串，检查是否作为子串出现在 DDDD（后四位）中。
（如果你希望“出现”必须和位数对齐，例如 sum=12 必须以两位 12 精确出现，而不是只出现 2，当前实现就是精确子串匹配 str(sum) —— 这是通常的做法。）
规则4：把所有数字连成一串（country+area+local），寻找任何单个数字重复 4 次或更多（例如 0000, 7777）即判 spam。

1st
```python=

```
